\section{Related Work}\label{Se:related}

As most of the research on privacy monitoring builds on the tainting approach, we survey related research mainly in this space. We also mention several specific studies in other areas.

\paragraph{Realtime Techniques} The state-of-the-art system for realtime privacy monitoring is TaintDroid~\cite{EGCCJMS:OSDI10}. TaintDroid features tolerable runtime overhead of about 10\%, and can track taint flow not only through variables and methods but also through files and messages passed between apps. TaintDroid has been used, extended and customized by several follow-up research projects. Jung et al.~\cite{JHW:SPSM12} enhance TaintDroid to track additional sources (including contacts, camera, microphone, etc). They used the enhanced version in a field study, which revealed 129 of the 223 apps they studied as vulnerable. 30 out of 257 alarms were judged as false positives. The Kynoid system~\cite{SPKS:WISTP12} extends TaintDroid with user-defined security policies, which include e.g. temporal constraints on data processing as well as restrictions on destinations to which data is released.

The main difference between \Tool\ and the approaches above, which all apply information-flow tracking, is that \Tool\ exercises ``fuzzy'' reasoning, in the form of statistical classification, rather than enforcing a clear-cut criterion. As part of this, \Tool\ factors into the privacy judgment the data values flowing into the sink statement, which provides additional evidence beyond data flow.

\paragraph{Quantitative Approaches} Different approaches have been proposed for quantitative information-flow analysis, all unified by the observation that data leakage is a quantitative rather than boolean judgment. McCamant and Ernst~\cite{ME:PLDI08} present an offline dynamic analysis that measures the amount of secret information that can be inferred from a program's outputs, where the text of the program is considered public. Their approach relies on taint analysis at the bit level. It provides a sound upper bound on the actual information flow, but only with respect to the observed runs.
Newsome et al.~\cite{NMS:PLAS09} develop complementary techniques to bound a program's \emph{channel capacity} using decision procedures (SAT and \#SAT solvers). They apply these techniques to the problem of false positives in dynamic taint analysis. Backes et al.~\cite{BKR:SP09} measure leakage in terms of indistinguishability, or equivalence, between outputs due to different secret artifacts. Their characterization of equivalence relations builds on the information-theoretic notion of entropy.
Budi et al.~\cite{BLJL:PLDI11} propose $kb$-anonymity, a model inspired by $k$-anonymity for ensuring safe release of private data for the purposes of testing and debugging. Like $k$-anonymity, $kb$-anonymity replaces certain information in the original data for privacy preservation, but beyond that, it also ensures that the replaced data does not lead to divergent program behaviors, and thus testing and debugging are still effective.

While these proposals have all been shown useful, none of these approaches has been shown to be efficient enough to meet realtime constraints. The algorithmic complexity of computing the information-theoretic measures introduced by these works seriously limits their applicability in a realtime setting. Our approach, instead, enables a quantitative/probabilistic mode of reasoning that is simultaneously lightweight, and therefore acceptable for online monitoring, by focusing on relevant features that are efficiently computable.

\paragraph{Static and Hybrid Analysis} The PiOS tool~\cite{EKKV:NDSS11} performs static leakage analysis of iOS applications. PiOS combines backward slicing with forward constant propagation for accurate resolution of method calls. It then performs standard taint analysis atop the resulting call graph, where path length is (unsoundly) limited to a maximum of 100 basic blocks. The authors report that over half of the 1,400 apps they analyzed leak the unique ID of their host device.
Graa et al.~\cite{GCCC:CSS12} propose a hybrid tainting technique that augments dynamic taint analysis with certain classes of implicit flows (namely, those due to conditional statements). To do so, they apply intraprocedural static analysis to the control flow graph of a method at load time to detect variable assignments that occur only under one conditional branch. The FlowDroid tool~\cite{FARBBKTOM:TR13} performs static leakage analysis of Android applications using tainting. It accounts for the Android lifecycle model, handles callbacks and features flow, field and object sensitivity. FlowDroid builds on, and extends, previous taint analyses designed for the server side~\cite{TPFSW:PLDI09,TPCCG:FASE13} as well as client side~\cite{GPTDTB:ISSTA11} of web applications.

In our experience, even precise static analysis techniques often suffer from a large number of false findings. These are due both to the qualitative (and coarse) nature of taint analysis and to other approximations (e.g., call-graph imprecisions). As for hybrid techniques, current techniques address challenges like implicit flows, where our experience suggests that for effective detection of data leakage by authentic apps, a more important dimension is the form and quantity of released information. In \secref{conclusion}, we outline a hybrid variant of \Tool\ that we plan to develop.

\paragraph{Offline Algorithms} The AppsPlayground framework~\cite{RCE:CODASPY13}, built atop TaintDroid, performs dynamic analysis of mobile apps. It features automatic triggering of system events, including usage of contextual information to provide meaningful textual input. The AdRisk system~\cite{GZJS:SPWMN12} identifies potential privacy and security risks due to embedded in-app advertisement libraries. It first decouples the embedded ad libraries from the host app, and then applies state analysis to each of the libraries to approximate its behavior.
AdSplit~\cite{SDW:SEC12} handles third-party advertising services differently by recompiling the app to extract such services, which consequently run as separate processes under separate user IDs.

Our approach is extensible to the offline setting, e.g. by piggybacking on unit/integration tests and detecting leakage bugs during the development and testing phases of a mobile app. Our technique can also be integrated with frameworks like AppsPlayground, which provide automated crawling capabilities, to perform offline testing for leakage vulnerabilities. 

\JC{
\paragraph{Techniques for Protecting Web Applications}
There exist numerous static and dynamic approaches for preventing attacks on web applications, e.g., \cite{TPFSW:PLDI09,TPCCG:FASE13,GPTDTB:ISSTA11}. \emph{JR: Omer, more citations besides self-references?}
Most relevant to our work are Sekar's taint-inference technique for deducing taint propagation by comparing inputs and outputs of a protected server-side application~\cite{Sekar:2009}, and a similar browser-resident technique developed in a subsequent work~\cite{Pelizzi:Sekar:2012}.
While \Tool\ shares ideas with these approaches, it is explicitly designed for mobile devices and applications. 
Curtsinger et al.~\cite{Curtsinger:Livshits:Zorn:Seifert:2011} apply a Bayesian classifier for identifying JavaScript syntax elements that are highly predictive of malware. The solution proposed in that work, ZOZZLE, is used for analyzing application code in a static manner, while \Tool\ operates dynamically and focuses on data values.

}